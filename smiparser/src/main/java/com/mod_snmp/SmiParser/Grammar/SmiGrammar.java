/* Generated By:JavaCC: Do not edit this line. SmiGrammar.java */
package com.mod_snmp.SmiParser.Grammar;

import com.mod_snmp.SmiParser.ErrorHandler.Message;
import com.mod_snmp.SmiParser.ErrorHandler.Recovery;
import com.mod_snmp.SmiParser.ErrorHandler.RecoveryItem;
import com.mod_snmp.SmiParser.SyntaxTree.*;

import java.util.Vector;


public class SmiGrammar implements SmiGrammarConstants {
    public static void main(String args[]) throws ParseException
    {
        SmiGrammar parser;
        parser = new SmiGrammar(System.in);
        try {
            parser.ModuleDefinitionList();
            System.out.println("MIB file parsed successfully.");
        } catch (ParseException e) {
            System.out.println("MIB file failed to parse.");
            System.out.println(e.toString());
        }
    }

    /**  
     * Dummy Token to be used if a Token is not initialized due
     * to syntactical errors.
     */
    private NodeToken makeNodeToken(int ofKind, String str) {
        return new NodeToken(str, ofKind, -1, -1, -1, -1);
    }
    private NodeToken makeNodeToken(int ofKind) {
        return new NodeToken("", ofKind, -1, -1, -1, -1);
    }
    private NodeToken makeNodeToken(Token t) {
        NodeToken node = new NodeToken(t.image.intern(), t.kind,
                                                t.beginLine, t.beginColumn,
                                                t.endLine, t.endColumn);
        if ( t.specialToken == null ) {
            return node;
        }
        Vector temp = new Vector();
        Token orig = t;
        while ( t.specialToken != null ) {
            t = t.specialToken;
            temp.addElement(new NodeToken(t.image.intern(), t.kind,
                                                t.beginLine, t.beginColumn,
                                                t.endLine, t.endColumn));
        }
        // Reverse the special token list
        for ( int i = temp.size() - 1; i >= 0; --i ) {
            node.addSpecial((NodeToken)temp.elementAt(i));
        }
        node.trimSpecials();
        return node;
    }

    /**
     * The recover function to skip items until a specified Token.
     */
    private boolean is_in_set(Token token, int set[]) {
        return is_in_set(token.kind, set);
    }
    private boolean is_in_set(int kind, int set[]) {
        for (int i = 0; i < set.length; i++) {
            if (kind == set[i]) {
                return true;
            }
         }
         return false;
    }
    private void recovery(int until[]) {
        /* Get last correctly parsed Token. */
        while (0 < until.length) {
            Token t = getToken(1);
            if (is_in_set(t.kind, until)) {
                return;
            }
            t = getNextToken();
        }
    }
    private void recovery(Recovery until) {
        /* Get last correctly parsed Token. */
        while (!until.empty()) {
            if (until.contains(getToken(1).kind, getToken(2).kind)) {
                return;
            }
            getNextToken();
        }
    }
    private void skip(int nr) {
        while (nr-- > 0) {
            getNextToken();
        }
    }

    private void makeError(Token tok, String msg) {
        if (tok.kind == TEXT_T) {
            Message.error(tok.beginLine, "<quoted string: " + (tok.toString()).substring(0, 20) + "\"> " + msg);
        } else {
            Message.error(tok, tok.toString(), msg);
        }
    }
    private void error(ParseException e) {
        String expected = tokenImage[e.expectedTokenSequences[0][0]];
        for (int i = 1; i < e.expectedTokenSequences.length; i++) {
            expected += ", " + tokenImage[e.expectedTokenSequences[i][0]];
        }
        error(e, expected);
    }
    private void error(ParseException e, String expected) {
        makeError(e.currentToken.next, "after " + e.currentToken
                                                        + " expected " + expected);
    }

    private void handleError(ParseException e, int next, String expected) {
        handleError(e.currentToken.next, next, expected);
    }
    private void handleError(Token last, int next, String expected) {
        if (last.next.kind == next) {
            makeError(last.next, "missing " + expected);
        } else {
            makeError(last.next, "encountered expected " + expected);
            getNextToken();
        }
    }
    private void handleError(ParseException e, Recovery next, String clause, String expected) {
        handleError(e.currentToken.next, next, clause, expected);
    }
    private void handleError(Token tok, Recovery next, String clause, String expected) {
        if (next.contains(tok.kind)) {
            Message.error(tok.beginLine, clause + "-clause misses " + expected);
        } else {
            Message.error(tok.beginLine, clause + "-clause encountered a " +
                                ((tok.kind == TEXT_T) ? "<quoted string>" : tok.toString()) +
                                " expected " + expected);
        }
        recovery(next);
    }
    private void handleError(ParseException e, Recovery next, int clause, String expected) {
        handleError(e.currentToken.next, next, clause, expected);
    }
    private void handleError(Token last, Recovery next, int clause, String expected) {
        handleError(last, next, ((clause == TEXT_T) ? "<quoted string>" : tokenImage[clause]), expected);
    }
    private void handleError(ParseException e, Recovery next, String expected) {
        handleError(e.currentToken.next, next, expected);
    }
    private void handleError(Token tok, Recovery next, String expected) {
        if (next.contains(tok.kind)) {
            makeError(tok, "missing " + expected);
        } else {
            makeError(tok, "encountered expected " + expected);
        }
        recovery(next);
    }

  final public NodeList ModuleDefinitionList() throws ParseException {
    NodeList module_list = new NodeList();
    ModuleDefinition module;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TYPE_IDENTIFIER_T:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      module = ModuleDefinition();
          module_list.addNode(module);
    }
      module_list.nodes.trimToSize();
      {if (true) return module_list;}
    throw new Error("Missing return statement in function");
  }

  final public ModuleDefinition ModuleDefinition() throws ParseException {
    ModuleIdentifier module_id = null;
    Token definitions_t;
    Token assign_t;
    Token begin_t;
    Token var10;
    NodeList exp_symbols = new NodeList();
    Token var13;
    Token var17;
    NodeList imports_mod_list = new NodeList();
    ModuleImport imports_symbols;
    Token var21;
    NodeList var22 = new NodeList();
    Assignment var24;
    Token var36;
    Recovery next = new Recovery();
    int next_type[] = { ASSIGN_T };
    int next_value[] = { OBJECT_IDENTIFIER_T, OBJECT_TYPE_T,
                                 OBJECT_IDENTITY_T, OBJECT_GROUP_T,
                                 NOTIFICATION_TYPE_T, NOTIFICATION_GROUP_T,
                                 MODULE_IDENTITY_T, MODULE_COMPLIANCE_T,
                                 AGENT_CAPABILITIES_T, TRAP_TYPE_T };
    int next_macro[] = { MACRO_T };
    int next_assign[] = { ASSIGN_T };
    try {
      module_id = ModuleIdentifier();
      definitions_t = jj_consume_token(DEFINITIONS_T);
            next.push(END_T);
            next.push(new RecoveryItem(TYPE_IDENTIFIER_T, next_type));
            next.push(new RecoveryItem(INDEX_SYNTAX_T, next_type));
            next.push(new RecoveryItem(APPLICATION_SYNTAX_T, next_type));
            next.push(new RecoveryItem(OBJECT_SYNTAX_T, next_type));
            next.push(new RecoveryItem(SIMPLE_SYNTAX_T, next_type));
            next.push(new RecoveryItem(VALUE_IDENTIFIER_T, next_value));
            next.push(new RecoveryItem(OBJECT_TYPE_T, next_macro));
            next.push(new RecoveryItem(OBJECT_IDENTITY_T, next_macro));
            next.push(new RecoveryItem(OBJECT_GROUP_T, next_macro));
            next.push(new RecoveryItem(TEXTUAL_CONVENTION_T, next_macro));
            next.push(new RecoveryItem(NOTIFICATION_TYPE_T, next_macro));
            next.push(new RecoveryItem(NOTIFICATION_GROUP_T, next_macro));
            next.push(new RecoveryItem(MODULE_IDENTITY_T, next_macro));
            next.push(new RecoveryItem(MODULE_COMPLIANCE_T, next_macro));
            next.push(new RecoveryItem(AGENT_CAPABILITIES_T, next_macro));
            next.push(new RecoveryItem(TRAP_TYPE_T, next_macro));
            next.push(new RecoveryItem(IP_ADDRESS_T, next_assign));
            next.push(new RecoveryItem(NETWORK_ADDRESS_T, next_assign));
            next.push(new RecoveryItem(COUNTER_T, next_assign));
            next.push(new RecoveryItem(COUNTER32_T, next_assign));
            next.push(new RecoveryItem(COUNTER64_T, next_assign));
            next.push(new RecoveryItem(GAUGE_T, next_assign));
            next.push(new RecoveryItem(GAUGE32_T, next_assign));
            next.push(new RecoveryItem(TIMETICKS_T, next_assign));
            next.push(new RecoveryItem(OPAQUE_T, next_assign));
            next.push(new RecoveryItem(INTEGER32_T, next_assign));
            next.push(new RecoveryItem(UINTEGER32_T, next_assign));
            next.push(new RecoveryItem(UNSIGNED32_T, next_assign));
            next.push(IMPORTS_T);
            next.push(EXPORTS_T);
            next.push(BEGIN_T);
      AssignSymbol(next);
            next.pop(); /* BEGIN_T */

      begin_t = jj_consume_token(BEGIN_T);
            next.pop(); /* EXPORTS_T */

      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXPORTS_T:
        var10 = jj_consume_token(EXPORTS_T);
        exp_symbols = ModuleExport(exp_symbols);
        var13 = jj_consume_token(SEMI_COLON_T);
              exp_symbols.nodes.trimToSize();
        break;
      default:
        jj_la1[1] = jj_gen;
        ;
      }
            next.pop(); /* IMPORTS_T */

      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORTS_T:
        var17 = jj_consume_token(IMPORTS_T);
              next.push(SEMI_COLON_T);
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case OBJECT_TYPE_T:
          case OBJECT_IDENTITY_T:
          case OBJECT_GROUP_T:
          case TEXTUAL_CONVENTION_T:
          case NOTIFICATION_TYPE_T:
          case NOTIFICATION_GROUP_T:
          case MODULE_IDENTITY_T:
          case MODULE_COMPLIANCE_T:
          case AGENT_CAPABILITIES_T:
          case TRAP_TYPE_T:
          case CURRENT_T:
          case DEPRECATED_T:
          case OBSOLETE_T:
          case MANDATORY_T:
          case NOT_IMPLEMENTED_T:
          case COUNTER32_T:
          case COUNTER_T:
          case GAUGE32_T:
          case GAUGE_T:
          case TIMETICKS_T:
          case OPAQUE_T:
          case IP_ADDRESS_T:
          case NETWORK_ADDRESS_T:
          case NSAP_ADDRESS_T:
          case COUNTER64_T:
          case UNSIGNED32_T:
          case UINTEGER32_T:
          case INTEGER32_T:
          case INDEX_SYNTAX_T:
          case APPLICATION_SYNTAX_T:
          case OBJECT_SYNTAX_T:
          case SIMPLE_SYNTAX_T:
          case VALUE_IDENTIFIER_T:
          case TYPE_IDENTIFIER_T:
            ;
            break;
          default:
            jj_la1[2] = jj_gen;
            break label_2;
          }
          try {
            imports_symbols = ModuleImport(next);
                      imports_mod_list.addNode(imports_symbols);
          } catch (ParseException e) {
                    if (e.currentToken.kind == FROM_T) {
                        makeError(e.currentToken, "incorrect module name");
                    }
                    if (e.currentToken.kind != SEMI_COLON_T) {
                        getNextToken();
                    }
          }
        }
                imports_mod_list.nodes.trimToSize();
                next.pop(); /* SEMI_COLON_T */

        var21 = jj_consume_token(SEMI_COLON_T);
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OBJECT_TYPE_T:
        case OBJECT_IDENTITY_T:
        case OBJECT_GROUP_T:
        case TEXTUAL_CONVENTION_T:
        case NOTIFICATION_TYPE_T:
        case NOTIFICATION_GROUP_T:
        case MODULE_IDENTITY_T:
        case MODULE_COMPLIANCE_T:
        case AGENT_CAPABILITIES_T:
        case TRAP_TYPE_T:
        case CURRENT_T:
        case DEPRECATED_T:
        case OBSOLETE_T:
        case MANDATORY_T:
        case NOT_IMPLEMENTED_T:
        case COUNTER32_T:
        case COUNTER_T:
        case GAUGE32_T:
        case GAUGE_T:
        case TIMETICKS_T:
        case OPAQUE_T:
        case IP_ADDRESS_T:
        case NETWORK_ADDRESS_T:
        case NSAP_ADDRESS_T:
        case COUNTER64_T:
        case UNSIGNED32_T:
        case UINTEGER32_T:
        case INTEGER32_T:
        case INDEX_SYNTAX_T:
        case APPLICATION_SYNTAX_T:
        case OBJECT_SYNTAX_T:
        case SIMPLE_SYNTAX_T:
        case VALUE_IDENTIFIER_T:
        case TYPE_IDENTIFIER_T:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_3;
        }
        var24 = Assignment(next);
                var22.addNode(var24);
                /* We do a recovery, making sure we see a next Assignment. */
                recovery(next);
      }
          var22.nodes.trimToSize();
      var36 = jj_consume_token(END_T);
    } catch (ParseException e) {
        makeError(e.currentToken,
                        "error in module " + ((module_id != null) ? module_id.toString() : ""));
        recovery(next);
    }
      {if (true) return new ModuleDefinition(module_id,
                            exp_symbols,
                            imports_mod_list,
                            var22);}
    throw new Error("Missing return statement in function");
  }

  NodeList ModuleExport(NodeList exports) throws ParseException {
    Token tok;
    while ( true ) {
        tok = getToken(1);
        if ((tok.kind == SEMI_COLON_T) && (tok.kind == IMPORTS_T)) {
            break;
        }
        if (tok.kind != COMMA_T) {
            exports.addNode(makeNodeToken(tok));
        }
        tok = getNextToken();
    }
    return exports;
  }

  final public ModuleImport ModuleImport(Recovery next) throws ParseException {
    NodeList symbol_list = new NodeList();
    Identifier symbol;
    Token comma_t;
    Token from_t;
    ModuleIdentifier module_id;
      next.push(FROM_T);
      next.push(COMMA_T);
    try {
      symbol = Symbol();
          symbol_list.addNode(symbol);
    } catch (ParseException e) {
        makeError(e.currentToken, "expected <symbol>");
        recovery(next);
    }
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_T:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_4;
      }
      try {
        comma_t = jj_consume_token(COMMA_T);
        symbol = Symbol();
              symbol_list.addNode(symbol);
      } catch (ParseException e) {
            if (e.currentToken.kind == COMMA_T) {
                makeError(e.currentToken, "encountered expected <symbol>");
                recovery(next);
            } else {
                handleError(e, next, "<symbol>");
            }
      }
    }
      symbol_list.nodes.trimToSize();
      next.pop(); /* COMMA_T */
      next.push(TYPE_IDENTIFIER_T);
    try {
      from_t = jj_consume_token(FROM_T);
    } catch (ParseException e) {
        makeError(e.currentToken, "expected 'FROM'");
        recovery(next);
        if (getToken(0).kind == FROM_T) {
            getNextToken();
        }
    } finally {
        next.pop(); /* FROM_T */
        next.pop(); /* TYPE_IDENTIFIER_T */

    }
    module_id = ModuleIdentifier();
      {if (true) return new ModuleImport(symbol_list,
                            module_id);}
    throw new Error("Missing return statement in function");
  }

  final public Identifier Symbol() throws ParseException {
    Identifier identifier;
    if (jj_2_1(3)) {
      identifier = TypeIdentifier();
    } else if (jj_2_2(3)) {
      identifier = ValueIdentifier();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INDEX_SYNTAX_T:
      case APPLICATION_SYNTAX_T:
      case OBJECT_SYNTAX_T:
      case SIMPLE_SYNTAX_T:
        identifier = TypeIdentifierException();
        break;
      case COUNTER32_T:
      case COUNTER_T:
      case GAUGE32_T:
      case GAUGE_T:
      case TIMETICKS_T:
      case OPAQUE_T:
      case IP_ADDRESS_T:
      case NETWORK_ADDRESS_T:
      case NSAP_ADDRESS_T:
      case COUNTER64_T:
      case UNSIGNED32_T:
      case UINTEGER32_T:
      case INTEGER32_T:
        identifier = SmiTypes();
        break;
      case OBJECT_TYPE_T:
      case OBJECT_IDENTITY_T:
      case OBJECT_GROUP_T:
      case TEXTUAL_CONVENTION_T:
      case NOTIFICATION_TYPE_T:
      case NOTIFICATION_GROUP_T:
      case MODULE_IDENTITY_T:
      case MODULE_COMPLIANCE_T:
      case AGENT_CAPABILITIES_T:
      case TRAP_TYPE_T:
        identifier = PredefinedMacro();
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return identifier;}
    throw new Error("Missing return statement in function");
  }

  final public Identifier PredefinedMacro() throws ParseException {
    Token var;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OBJECT_TYPE_T:
      var = jj_consume_token(OBJECT_TYPE_T);
      break;
    case OBJECT_IDENTITY_T:
      var = jj_consume_token(OBJECT_IDENTITY_T);
      break;
    case OBJECT_GROUP_T:
      var = jj_consume_token(OBJECT_GROUP_T);
      break;
    case TEXTUAL_CONVENTION_T:
      var = jj_consume_token(TEXTUAL_CONVENTION_T);
      break;
    case NOTIFICATION_TYPE_T:
      var = jj_consume_token(NOTIFICATION_TYPE_T);
      break;
    case NOTIFICATION_GROUP_T:
      var = jj_consume_token(NOTIFICATION_GROUP_T);
      break;
    case MODULE_IDENTITY_T:
      var = jj_consume_token(MODULE_IDENTITY_T);
      break;
    case MODULE_COMPLIANCE_T:
      var = jj_consume_token(MODULE_COMPLIANCE_T);
      break;
    case AGENT_CAPABILITIES_T:
      var = jj_consume_token(AGENT_CAPABILITIES_T);
      break;
    case TRAP_TYPE_T:
      var = jj_consume_token(TRAP_TYPE_T);
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return Identifier.Keyword(makeNodeToken(var));}
    throw new Error("Missing return statement in function");
  }

  final public Identifier SmiTypes() throws ParseException {
    Token var;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IP_ADDRESS_T:
      var = jj_consume_token(IP_ADDRESS_T);
      break;
    case NETWORK_ADDRESS_T:
      var = jj_consume_token(NETWORK_ADDRESS_T);
      break;
    case NSAP_ADDRESS_T:
      var = jj_consume_token(NSAP_ADDRESS_T);
      break;
    case COUNTER_T:
      var = jj_consume_token(COUNTER_T);
      break;
    case COUNTER32_T:
      var = jj_consume_token(COUNTER32_T);
      break;
    case COUNTER64_T:
      var = jj_consume_token(COUNTER64_T);
      break;
    case GAUGE_T:
      var = jj_consume_token(GAUGE_T);
      break;
    case GAUGE32_T:
      var = jj_consume_token(GAUGE32_T);
      break;
    case TIMETICKS_T:
      var = jj_consume_token(TIMETICKS_T);
      break;
    case OPAQUE_T:
      var = jj_consume_token(OPAQUE_T);
      break;
    case INTEGER32_T:
      var = jj_consume_token(INTEGER32_T);
      break;
    case UINTEGER32_T:
      var = jj_consume_token(UINTEGER32_T);
      break;
    case UNSIGNED32_T:
      var = jj_consume_token(UNSIGNED32_T);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return Identifier.Keyword(makeNodeToken(var));}
    throw new Error("Missing return statement in function");
  }

  final public Assignment Assignment(Recovery next) throws ParseException {
    Assignment assignment = null;
    Identifier identifier = null;
    Type type;
    MacroBody macro_body;
    Token begin_t;
    Token syntax_t;
    Token end_t;
    Token type_t;
    TypeTag typeTag;
    NodeList variables;
    EnterprisePart enterprise;
    DescriptionPart description;
    NumericValue number;
    NodeList vtList;
    ObjectInfo object_info;
    Token assign_t;
    AssignedValue assigned_value;
    if (jj_2_3(2)) {
      identifier = TypeIdentifier();
      AssignSymbol(new Recovery());
      type = TypeDefinition(next);
            assignment = new AssignmentType(identifier,
                        type);
    } else if (jj_2_4(2)) {
      identifier = ValueIdentifier();
            next.push(ASSIGN_T);
      try {
        object_info = ObjectDefinition(next);
      } catch (ParseException e) {
            object_info = new ObjectInfoObjectIdentifier();
            makeError(e.currentToken, "encountered in assignment '" + identifier + "'");
            recovery(next);
      } finally {
            /* Setup for continuation */
            next.pop(); /* ASSIGN_T */
            next.push(LEFT_BRACE_T);
      }
      AssignSymbol(next);
            next.pop(); /* LEFT_BRACE_T */

      assigned_value = AssignedValue();
          assignment = new AssignmentObject(identifier,
                            object_info,
                            assigned_value);
    } else if (jj_2_5(3)) {
      identifier = SmiTypes();
            next.push(INTEGER_T);
            next.push(BIT_STRING_T);
            next.push(OCTET_STRING_T);
            next.push(OBJECT_IDENTIFIER_T);
            next.push(LEFT_SQUARE_T);
      AssignSymbol(next);
            next.pop(); /* LEFT_SQUARE_T */

      typeTag = TypeTag(next);
            if (!next.contains(getToken(1).kind)) {
                recovery(next);
            }
            next.pop(4); /* OBJECT_IDENTIFIER_T, OCTET_STRING_T, BIT_STRING_T, INTEGER_T */

      type = Asn1Types();
            typeTag.setType((TypeSmi)type);
            assignment = new AssignmentType(identifier,
                                        typeTag);
    } else if (jj_2_6(3)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COUNTER32_T:
      case COUNTER_T:
      case GAUGE32_T:
      case GAUGE_T:
      case TIMETICKS_T:
      case OPAQUE_T:
      case IP_ADDRESS_T:
      case NETWORK_ADDRESS_T:
      case NSAP_ADDRESS_T:
      case COUNTER64_T:
      case UNSIGNED32_T:
      case UINTEGER32_T:
      case INTEGER32_T:
        identifier = SmiTypes();
        break;
      case INDEX_SYNTAX_T:
      case APPLICATION_SYNTAX_T:
      case OBJECT_SYNTAX_T:
      case SIMPLE_SYNTAX_T:
        identifier = TypeIdentifierException();
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            next.push(CHOICE_T);
      AssignSymbol(next);
            next.pop(); /* CHOICE_T */

      type_t = jj_consume_token(CHOICE_T);
      vtList = BracedValueTypeList();
            assignment = new AssignmentType(identifier,
                                        new TypeChoice(vtList));
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJECT_TYPE_T:
      case OBJECT_IDENTITY_T:
      case OBJECT_GROUP_T:
      case TEXTUAL_CONVENTION_T:
      case NOTIFICATION_TYPE_T:
      case NOTIFICATION_GROUP_T:
      case MODULE_IDENTITY_T:
      case MODULE_COMPLIANCE_T:
      case AGENT_CAPABILITIES_T:
      case TRAP_TYPE_T:
        identifier = PredefinedMacro();
        /* Is actually a TypeIdentifier() */
                type_t = jj_consume_token(MACRO_T);
            next.push(BEGIN_T);
        AssignSymbol(next);
            next.pop(); /* BEGIN_T */

        begin_t = jj_consume_token(BEGIN_T);
        macro_body = MacroBody();
        end_t = jj_consume_token(END_T);
            assignment = new AssignmentMacro(identifier,
                                        macro_body);
        break;
      default:
        jj_la1[10] = jj_gen;
        if (jj_2_7(2)) {
          identifier = ValueIdentifier();
          type_t = jj_consume_token(TRAP_TYPE_T);
            next.push(ASSIGN_T);
            next.push(DESCRIPTION_T);
            next.push(VARIABLES_T);
          enterprise = EnterprisePart(next);
            next.pop(); /* VARIABLES_T */

          variables = VariablesPart(next);
            next.pop(); /* DESCRIPTION_T */

          description = DescriptionPart(next);
            next.pop(); /* ASSIGN_T */

            next.push(DEC_NUMBER_T);
            next.push(BIN_NUMBER_T);
            next.push(HEX_NUMBER_T);
            next.push(VALUE_IDENTIFIER_T);
            next.push(TYPE_IDENTIFIER_T);
          AssignSymbol(next);
            next.pop(3); /* DEC_NUMBER_T, BIN_NUMBER_T, HEX_NUMBER_T */

          number = NumericValue();
            next.pop(2); /* VALUE_IDENTIFIER_T, TYPE_IDENTIFIER_T */
            assignment = new AssignmentObject(identifier,
                        new ObjectInfoTrapType(enterprise,
                                        variables,
                                        description,
                                        number),
                        number);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
        {if (true) return assignment;}
    throw new Error("Missing return statement in function");
  }

/**
 * TypeDefinition()
 * Returns a allowed type definition of a MIB module.
 * There are 3 kinds of TypeDefinitions.
 * 1) derived_type ::= basic_type
 *    Only allowed for SMIv1.
 * 2) derived_type ::= textual convention
 *    Only allowed for SMIv2.
 * 3) derived-type ::= sequence
 *    Needed to define the row of a table.
 */
  final public Type TypeDefinition(Recovery next) throws ParseException {
    Type type;
    DisplayHintPart displayhint;
    SyntaxPart syntax;
    StatusPart status;
    DescriptionPart description;
    ReferencePart reference;
    Token type_t;
    NodeList vtList;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OBJECT_IDENTIFIER_T:
    case INTEGER_T:
    case BITS_T:
    case BIT_STRING_T:
    case OCTET_STRING_T:
    case SEQUENCE_OF_T:
    case COUNTER32_T:
    case COUNTER_T:
    case GAUGE32_T:
    case GAUGE_T:
    case TIMETICKS_T:
    case OPAQUE_T:
    case IP_ADDRESS_T:
    case NETWORK_ADDRESS_T:
    case NSAP_ADDRESS_T:
    case COUNTER64_T:
    case UNSIGNED32_T:
    case UINTEGER32_T:
    case INTEGER32_T:
    case TYPE_IDENTIFIER_T:
      /* Only added for SMIv1 support. */
              type = Types();
      break;
    case TEXTUAL_CONVENTION_T:
      type_t = jj_consume_token(TEXTUAL_CONVENTION_T);
            next.push(SYNTAX_T);
            next.push(REFERENCE_T);
            next.push(DESCRIPTION_T);
            next.push(STATUS_T);
      displayhint = DisplayHintPart(next);
            next.pop(); /* STATUS_T */

      status = StatusPart(next);
            next.pop(); /* DESCRIPTION_T */

      description = DescriptionPart(next);
            next.pop(); /* REFERENCE_T */

      reference = ReferencePart(next);
            next.pop(); /* SYNTAX_T */

      syntax = SyntaxPart(next);
            type = new TypeTextualConvention(displayhint,
                            status,
                            description,
                            reference,
                            syntax);
      break;
    case SEQUENCE_T:
      type_t = jj_consume_token(SEQUENCE_T);
      vtList = BracedValueTypeList();
          type = new TypeSequence(vtList);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return type;}
    throw new Error("Missing return statement in function");
  }

  final public ObjectInfo ObjectDefinition(Recovery next) throws ParseException {
    Type type;
    Token sort_t;
    ContactInfoPart contactinfo;
    NodeList revision;
    OrganizationPart organization;
    SyntaxPart syntax;
    UnitsPart units;
    AccessPart access;
    StatusPart status;
    DescriptionPart description;
    ReferencePart reference;
    IndexPart index;
    DefValPart defval;
    NodeList objects;
    NodeList notification;
    NodeList modulecapabilities;
    NodeList modulecompliance;
    ProductReleasePart productrelease;
    LastUpdatedPart lastupdated;
    NumericValue number;
    Token type_t;
    ObjectInfo object_info;
    AssignedValue assigned_value;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OBJECT_IDENTIFIER_T:
      sort_t = jj_consume_token(OBJECT_IDENTIFIER_T);
            object_info = new ObjectInfoObjectIdentifier();
      break;
    case OBJECT_TYPE_T:
      sort_t = jj_consume_token(OBJECT_TYPE_T);
            next.push(DEFVAL_T);
            next.push(INDEX_T);
            next.push(REFERENCE_T);
            next.push(DESCRIPTION_T);
            next.push(STATUS_T);
            next.push(MAX_ACCESS_T);
            next.push(UNITS_T);
      syntax = SyntaxPart(next);
            next.pop(); /* UNITS_T */

      units = UnitsPart(next);
            next.pop(); /* MAX_ACCESS_T */
            next.contains(-1);
      access = AccessPart(MAX_ACCESS_T, next);
            next.pop(); /* STATUS_T */

      status = StatusPart(next);
            next.pop(); /* DESCRIPTION_T */

      description = DescriptionPart(next);
            next.pop(); /* REFERENCE_T */

      reference = ReferencePart(next);
            next.pop(); /* INDEX_T */

      index = IndexPart(next);
            next.pop(); /* DEFVAL_T */

      defval = DefValPart(next);
            object_info = new ObjectInfoObjectType(syntax,
                                            units,
                                            access,
                                            status,
                                            description,
                                            reference,
                                            index,
                                            defval);
      break;
    case MODULE_IDENTITY_T:
      sort_t = jj_consume_token(MODULE_IDENTITY_T);
            next.push(REVISION_T);
            next.push(DESCRIPTION_T);
            next.push(CONTACT_INFO_T);
            next.push(ORGANIZATION_T);
      lastupdated = LastUpdatedPart(next);
            next.pop(); /* ORGANIZATION_T */

      organization = OrganizationPart(next);
            next.pop(); /* CONTACT_INFO_T */

      contactinfo = ContactInfoPart(next);
            next.pop(); /* DESCRIPTION_T */

      description = DescriptionPart(next);
            next.pop(); /* REVISION_T */

      revision = RevisionPart(next);
            object_info = new ObjectInfoModuleIdentity(lastupdated,
                                            organization,
                                            contactinfo,
                                            description,
                                            revision);
      break;
    case OBJECT_IDENTITY_T:
      sort_t = jj_consume_token(OBJECT_IDENTITY_T);
            next.push(REFERENCE_T);
            next.push(DESCRIPTION_T);
      status = StatusPart(next);
            next.pop(); /* DESCRIPTION_T */

      description = DescriptionPart(next);
            next.pop(); /* REFERENCE_T */

      reference = ReferencePart(next);
            object_info = new ObjectInfoObjectIdentity(status,
                                            description,
                                            reference);
      break;
    case OBJECT_GROUP_T:
      sort_t = jj_consume_token(OBJECT_GROUP_T);
            next.push(REFERENCE_T);
            next.push(DESCRIPTION_T);
            next.push(STATUS_T);
      objects = ObjectsPart(false, next);
            next.pop(); /* STATUS_T */

      status = StatusPart(next);
            next.pop(); /* DESCRIPTION_T */

      description = DescriptionPart(next);
            next.pop(); /* REFERENCE_T */

      reference = ReferencePart(next);
            object_info = new ObjectInfoObjectGroup(objects,
                                            status,
                                            description,
                                            reference);
      break;
    case NOTIFICATION_TYPE_T:
      sort_t = jj_consume_token(NOTIFICATION_TYPE_T);
            next.push(REFERENCE_T);
            next.push(DESCRIPTION_T);
            next.push(STATUS_T);
      objects = ObjectsPart(true, next);
            next.pop(); /* STATUS_T */

      status = StatusPart(next);
            next.pop(); /* DESCRIPTION_T */

      description = DescriptionPart(next);
            next.pop(); /* REFERENCE_T */

      reference = ReferencePart(next);
            object_info = new ObjectInfoNotificationType(objects,
                                            status,
                                            description,
                                            reference);
      break;
    case NOTIFICATION_GROUP_T:
      sort_t = jj_consume_token(NOTIFICATION_GROUP_T);
            next.push(REFERENCE_T);
            next.push(DESCRIPTION_T);
            next.push(STATUS_T);
      notification = NotificationPart(next);
            next.pop(); /* STATUS_T */

      status = StatusPart(next);
            next.pop(); /* DESCRIPTION_T */

      description = DescriptionPart(next);
            next.pop(); /* REFERENCE_T */

      reference = ReferencePart(next);
            object_info = new ObjectInfoNotificationGroup(notification,
                                            status,
                                            description,
                                            reference);
      break;
    case MODULE_COMPLIANCE_T:
      sort_t = jj_consume_token(MODULE_COMPLIANCE_T);
            next.push(MODULE_T);
            next.push(REFERENCE_T);
            next.push(DESCRIPTION_T);
      status = StatusPart(next);
            next.pop(); /* DESCRIPTION_T */

      description = DescriptionPart(next);
            next.pop(); /* REFERENCE_T */

      reference = ReferencePart(next);
            next.pop(); /* MODULE_T */

      modulecompliance = ModuleCompliancePart();
            object_info = new ObjectInfoModuleCompliance(status,
                                            description,
                                            reference,
                                            modulecompliance);
      break;
    case AGENT_CAPABILITIES_T:
      sort_t = jj_consume_token(AGENT_CAPABILITIES_T);
            next.push(SUPPORTS_T);
            next.push(REFERENCE_T);
            next.push(DESCRIPTION_T);
            next.push(STATUS_T);
      productrelease = ProductReleasePart(next);
            next.pop(); /* STATUS_T */

      status = StatusPart(next);
            next.pop(); /* DESCRIPTION_T */

      description = DescriptionPart(next);
            next.pop(); /* REFERENCE_T */

      reference = ReferencePart(next);
            next.pop(); /* SUPPORTS_T */

      modulecapabilities = ModuleCapabilitiesPart();
            object_info = new ObjectInfoAgentCapabilities(productrelease,
                                            status,
                                            description,
                                            reference,
                                            modulecapabilities);
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return object_info;}
    throw new Error("Missing return statement in function");
  }

  MacroBody MacroBody() throws ParseException {
    Token tok;
    while ( true ) {
        tok = getToken(1);
        if ( tok.kind == END_T ) {
            break;
        }
        tok = getNextToken();
    }
    return new MacroBody();
  }

  TypeChoice TypeChoice() throws ParseException {
    Token tok;
    NodeList items = new NodeList();
    int nesting = 0;
    tok = getNextToken();
    if ( tok.kind == LEFT_BRACE_T ) {
        nesting = 1;
    }
    while ( nesting > 0 ) {
        tok = getNextToken();
        if ( tok.kind == LEFT_BRACE_T ) {
            nesting++;
        }
        if ( tok.kind == RIGHT_BRACE_T ) {
            nesting--;
        }
    }
    return new TypeChoice(items);
  }

  final public TypeTag TypeTag(Recovery next) throws ParseException {
    Token lsquare;
    Token sort;
    Token number;
    Token rsquare;
    Token kind;
    TypeTag typeTag = new TypeTag();
    next.push(DEC_NUMBER_T);
    next.push(RIGHT_SQUARE_T);
    next.push(EXPLICIT_T);
    next.push(IMPLICIT_T);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_SQUARE_T:
      lsquare = jj_consume_token(LEFT_SQUARE_T);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case APPLICATION_T:
          sort = jj_consume_token(APPLICATION_T);
          break;
        case UNIVERSAL_T:
          sort = jj_consume_token(UNIVERSAL_T);
          break;
        case PRIVATE_T:
          sort = jj_consume_token(PRIVATE_T);
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
              typeTag.setSort(makeNodeToken(sort));
      } catch (ParseException e) {
            handleError(e, next,
                                        "tag sort <APPLICATION/UNIVERSAL/PRIVATE>");
      } finally {
            next.pop(); /* DEC_NUMBER_T */

      }
      try {
        number = jj_consume_token(DEC_NUMBER_T);
              typeTag.setNumber(new NumericValue(makeNodeToken(number)));
      } catch (ParseException e) {
            handleError(e, next, "<decimal tag number>");
      } finally {
            next.pop(); /* RIGHT_SQUARE_T */

      }
      rsquare = jj_consume_token(RIGHT_SQUARE_T);
            next.pop(2); /* EXPLICIT_T, IMPLICIT_T */

      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXPLICIT_T:
      case IMPLICIT_T:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EXPLICIT_T:
          kind = jj_consume_token(EXPLICIT_T);
          break;
        case IMPLICIT_T:
          kind = jj_consume_token(IMPLICIT_T);
          break;
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
              typeTag.setKind(makeNodeToken(kind));
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
      {if (true) return typeTag;}
    throw new Error("Missing return statement in function");
  }

  final public TypeSmi Asn1Types() throws ParseException {
    TypeSmi type;
    Token type_t;
    Restriction restriction;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_T:
      /* INTEGER type, has an optional range restriction. */
              type_t = jj_consume_token(INTEGER_T);
          type = new TypeSmi(makeNodeToken(type_t));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_PAREN_T:
        restriction = RestrictionRange();
              type.addRestriction(restriction);
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      break;
    case BIT_STRING_T:
      /* BITS types, have an optional name/number list restriction. */
              type_t = jj_consume_token(BIT_STRING_T);
          type = new TypeSmi(makeNodeToken(type_t));
      break;
    case OCTET_STRING_T:
      /* OCTET STRING type, has an optional size restriction. */
              type_t = jj_consume_token(OCTET_STRING_T);
          type = new TypeSmi(makeNodeToken(type_t));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_PAREN_T:
        restriction = RestrictionSize(new Recovery(new int[0]));
              type.addRestriction(restriction);
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      break;
    case OBJECT_IDENTIFIER_T:
      type_t = jj_consume_token(OBJECT_IDENTIFIER_T);
          type = new TypeSmi(makeNodeToken(type_t));
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return type;}
    throw new Error("Missing return statement in function");
  }

  final public NodeList RevisionPart(Recovery next) throws ParseException {
    NodeList revisions = new NodeList();
    Token revision_t;
    Token time_t;
    NodeToken time;
    DescriptionPart description;
    next.push(REVISION_T);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REVISION_T:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_5;
      }
      revision_t = jj_consume_token(REVISION_T);
            next.push(DESCRIPTION_T);
      try {
        time_t = jj_consume_token(UTC_TIME_T);
      } catch (ParseException e) {
            handleError(e, next, "<utc time>");
            time_t = new Token();
      } finally {
            next.pop(); /* DESCRIPTION_T */

      }
      description = DescriptionPart(next);
            revisions.addNode(new Revision(
                        makeNodeToken(time_t), description));
    }
      revisions.nodes.trimToSize();
      {if (true) return revisions;}
    throw new Error("Missing return statement in function");
  }

  final public StatusPart StatusPart(Recovery next) throws ParseException {
    Token key;
    Token value;
    NodeToken status;
    try {
      key = jj_consume_token(STATUS_T);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURRENT_T:
        value = jj_consume_token(CURRENT_T);
        break;
      case DEPRECATED_T:
        value = jj_consume_token(DEPRECATED_T);
        break;
      case OBSOLETE_T:
        value = jj_consume_token(OBSOLETE_T);
        break;
      case MANDATORY_T:
        value = jj_consume_token(MANDATORY_T);
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          status = makeNodeToken(value);
    } catch (ParseException e) {
        if (e.currentToken.kind == STATUS_T) {
            handleError(e, next, "<status value>");
            status = makeNodeToken(-1);
        } else if ((e.currentToken.next.kind == CURRENT_T) ||
                   (e.currentToken.next.kind == DEPRECATED_T) ||
                   (e.currentToken.next.kind == CURRENT_T) ||
                   (e.currentToken.next.kind == CURRENT_T)) {
            Token tok = getNextToken();
            Message.error(tok.beginLine, "missing 'STATUS'-keyword");
            status = makeNodeToken(tok);
        } else {
            Message.error(getToken(1).beginLine, "STATUS-clause missing");
            status = makeNodeToken(-1);
            recovery(next);
        }
    }
      {if (true) return new StatusPart(status);}
    throw new Error("Missing return statement in function");
  }

  final public AccessPart AccessPart(int access_type, Recovery next) throws ParseException {
    Token key;
    Token value;
    AccessPart access = new AccessPart();
    Recovery next_values = new Recovery();
    next_values.push(NOT_ACCESSIBLE_T);
    next_values.push(ACCESSIBLE_FOR_NOTIFY_T);
    next_values.push(READ_ONLY_T);
    next_values.push(READ_WRITE_T);
    next_values.push(READ_CREATE_T);
    next_values.push(WRITE_ONLY_T);
    next_values.push(NOT_IMPLEMENTED_T);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ACCESS_T:
        key = jj_consume_token(ACCESS_T);
        break;
      case MIN_ACCESS_T:
        key = jj_consume_token(MIN_ACCESS_T);
        break;
      case MAX_ACCESS_T:
        key = jj_consume_token(MAX_ACCESS_T);
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            access.key = makeNodeToken(key);
    } catch (ParseException e) {
        access.key = makeNodeToken(access_type, tokenImage[access_type]);
        if (next_values.contains(e.currentToken.next.kind)) {
            handleError(e, next, tokenImage[access_type]);
        } else {
            StringBuffer str = new StringBuffer(tokenImage[access_type]);
            str.deleteCharAt(0);
            str.deleteCharAt(str.length()-1);
            Message.error(getToken(1).beginLine, str + "-clause missing");
            access.value = makeNodeToken(-1);
            {if (true) return access;}
        }
    }
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOT_ACCESSIBLE_T:
        value = jj_consume_token(NOT_ACCESSIBLE_T);
        break;
      case ACCESSIBLE_FOR_NOTIFY_T:
        value = jj_consume_token(ACCESSIBLE_FOR_NOTIFY_T);
        break;
      case READ_ONLY_T:
        value = jj_consume_token(READ_ONLY_T);
        break;
      case READ_WRITE_T:
        value = jj_consume_token(READ_WRITE_T);
        break;
      case READ_CREATE_T:
        value = jj_consume_token(READ_CREATE_T);
        break;
      case WRITE_ONLY_T:
        value = jj_consume_token(WRITE_ONLY_T);
        break;
      case NOT_IMPLEMENTED_T:
        value = jj_consume_token(NOT_IMPLEMENTED_T);
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            access.value = makeNodeToken(value);
    } catch (ParseException e) {
        handleError(e, next, "<access value>");
        access.value = makeNodeToken(-1);
    }
        {if (true) return access;}
    throw new Error("Missing return statement in function");
  }

  final public NodeList ModuleCompliancePart() throws ParseException {
    NodeList module_list = new NodeList();
    ModuleCompliance module_compliance;
    label_6:
    while (true) {
      module_compliance = ModuleCompliance();
          module_list.addNode(module_compliance);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MODULE_T:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_6;
      }
    }
      module_list.nodes.trimToSize();
      {if (true) return module_list;}
    throw new Error("Missing return statement in function");
  }

  final public ModuleCompliance ModuleCompliance() throws ParseException {
    Token module_t;
    ModuleIdentifier module_id;
    NodeList mandatory;
    CompliancePart compliance;
    ModuleCompliance module_compliance = new ModuleCompliance();
    Recovery next = new Recovery();
    next.push(ASSIGN_T);
    next.push(GROUP_T);
    next.push(OBJECT_T);
    module_t = jj_consume_token(MODULE_T);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TYPE_IDENTIFIER_T:
      module_id = ModuleIdentifier();
          module_compliance.addModuleIdentifier(module_id);
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MANDATORY_GROUPS_T:
      mandatory = MandatoryPart(next);
          module_compliance.addMandatoryPart(mandatory);
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GROUP_T:
      case OBJECT_T:
        ;
        break;
      default:
        jj_la1[27] = jj_gen;
        break label_7;
      }
      try {
        compliance = CompliancePart(next);
              module_compliance.addCompliancePart(compliance);
      } catch (ParseException e) {
            handleError(e, next, "<compliance part>");
      }
    }
      {if (true) return module_compliance;}
    throw new Error("Missing return statement in function");
  }

  final public NodeList MandatoryPart(Recovery next) throws ParseException {
    Token mandatory_groups_t;
    NodeList list;
    mandatory_groups_t = jj_consume_token(MANDATORY_GROUPS_T);
    list = BracedValueList(next);
      {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final public CompliancePart CompliancePart(Recovery next) throws ParseException {
    Token sort_t;
    Identifier identifier;
    DescriptionPart description;
    SyntaxPart syntax;
    WriteSyntaxPart write_syntax;
    AccessPart min_access;
    ComplianceObject compliance_object;
    CompliancePart compliance;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GROUP_T:
      sort_t = jj_consume_token(GROUP_T);
      identifier = ValueIdentifier();
      description = DescriptionPart(next);
            compliance = new ComplianceGroup(identifier, description);
      break;
    case OBJECT_T:
            boolean has_syntax = false;
            boolean has_write_syntax = false;
            boolean has_min_access = false;
            next.push(DESCRIPTION_T);
            next.push(MIN_ACCESS_T);
            next.push(WRITE_SYNTAX_T);
            next.push(SYNTAX_T);
      sort_t = jj_consume_token(OBJECT_T);
      identifier = ValueIdentifier();
            compliance_object = new ComplianceObject(identifier);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SYNTAX_T:
        syntax = SyntaxPart(next);
                compliance_object.addNode(syntax);
                has_syntax = true;
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
            next.pop(); /* SYNTAX_T */

      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WRITE_SYNTAX_T:
        write_syntax = WriteSyntaxPart(next);
                compliance_object.addNode(write_syntax);
                has_write_syntax = true;
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
            next.pop(); /* WRITE_SYNTAX_T */

      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ACCESS_T:
      case MAX_ACCESS_T:
      case MIN_ACCESS_T:
        min_access = AccessPart(MIN_ACCESS_T, next);
                compliance_object.addNode(min_access);
                has_min_access = true;
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
            next.pop(); /* MIN_ACCESS_T */

            if (getToken(1).kind != DESCRIPTION_T) {
                String str = "";
                if (!has_min_access) {
                    str += "MIN-ACCESS-";
                    if (!has_write_syntax) {
                        str += ", WRITE-SYNTAX-";
                        if (!has_syntax) {
                            str += ", SYNTAX-";
                        }
                    }
                    str += " or ";
                }
                makeError(getToken(1), "expected " + str + "DESCRIPTION-clause");
                recovery(next);
            }
            next.pop(); /* DESCRIPTION_T */

      description = DescriptionPart(next);
            next.pop(); /* DESCRIPTION_T */
            compliance_object.addNode(description);
            compliance = compliance_object;
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return compliance;}
    throw new Error("Missing return statement in function");
  }

  final public NodeList ModuleCapabilitiesPart() throws ParseException {
    NodeList module_capabilities_list = new NodeList();
    ModuleCapability module_capability;
    Recovery next = new Recovery();
    next.push(ASSIGN_T);
    next.push(SUPPORTS_T);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SUPPORTS_T:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_8;
      }
      module_capability = ModuleCapability(next);
          module_capabilities_list.addNode(module_capability);
    }
      {if (true) return module_capabilities_list;}
    throw new Error("Missing return statement in function");
  }

  final public ModuleCapability ModuleCapability(Recovery next) throws ParseException {
    NodeList capabilitiesList;
    Token support_t;
    ModuleIdentifier module_id;
    Token includes_t;
    NodeList list;
    NodeList variation_list = new NodeList();
    VariationPart variation;
    support_t = jj_consume_token(SUPPORTS_T);
    try {
      module_id = ModuleIdentifier();
    } catch (ParseException e) {
        handleError(e, INCLUDES_T, "<module identifier>");
        module_id = new ModuleIdentifier(makeNodeToken(TYPE_IDENTIFIER_T));
    }
    try {
      includes_t = jj_consume_token(INCLUDES_T);
    } catch (ParseException e) {
        handleError(e, LEFT_BRACE_T, "'INCLUDES'");
    }
    list = BracedValueList(next);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIATION_T:
        ;
        break;
      default:
        jj_la1[33] = jj_gen;
        break label_9;
      }
      variation = VariationPart();
          variation_list.addNode(variation);
    }
      variation_list.nodes.trimToSize();
      {if (true) return new ModuleCapability(module_id,
                            list,
                            variation_list);}
    throw new Error("Missing return statement in function");
  }

  final public VariationPart VariationPart() throws ParseException {
    Token variation_t;
    Identifier identifier;
    SyntaxPart syntax;
    NodeOptional syntax_option = new NodeOptional();
    WriteSyntaxPart write_syntax;
    NodeOptional write_syntax_option = new NodeOptional();
    AccessPart access;
    NodeOptional access_option = new NodeOptional();
    Token creation_t;
    NodeList list;
    NodeOptional creation_option = new NodeOptional();
    DefValPart defval;
    DescriptionPart description;
    Recovery next = new Recovery();
    next.push(DESCRIPTION_T);
    next.push(DEFVAL_T);
    next.push(CREATION_REQUIRES_T);
    next.push(ACCESS_T);
    next.push(WRITE_SYNTAX_T);
    next.push(SYNTAX_T);
    variation_t = jj_consume_token(VARIATION_T);
    try {
      identifier = ValueIdentifier();
    } catch (ParseException e) {
        handleError(e, next, "<value identifier>");
        identifier = Identifier.Value(makeNodeToken(VALUE_IDENTIFIER_T));
    } finally {
        next.pop(); /* SYNTAX_T */

    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SYNTAX_T:
      syntax = SyntaxPart(next);
          syntax_option.addNode(syntax);
      break;
    default:
      jj_la1[34] = jj_gen;
      ;
    }
        next.pop(); /* WRITE_SYNTAX_T */

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WRITE_SYNTAX_T:
      write_syntax = WriteSyntaxPart(next);
          write_syntax_option.addNode(write_syntax);
      break;
    default:
      jj_la1[35] = jj_gen;
      ;
    }
        next.pop(); /* ACCESS_T */

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ACCESS_T:
    case MAX_ACCESS_T:
    case MIN_ACCESS_T:
      access = AccessPart(ACCESS_T, next);
          access_option.addNode(access);
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
        next.pop(); /* CREATION_REQUIRES_T */

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATION_REQUIRES_T:
      creation_t = jj_consume_token(CREATION_REQUIRES_T);
      list = BracedValueList(next);
          creation_option.addNode(list);
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
        next.pop(); /* DEFVAL_T */

    defval = DefValPart(next);
        next.pop(); /* DESCRIPTION_T */

    description = DescriptionPart(next);
      {if (true) return new VariationPart(identifier,
                            syntax_option,
                            write_syntax_option,
                            access_option,
                            creation_option,
                            defval,
                            description);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxPart SyntaxPart(Recovery next) throws ParseException {
    Token key;
    Type type;
    try {
      key = jj_consume_token(SYNTAX_T);
      type = Types();
    } catch (ParseException e) {
        if (e.currentToken.kind == SYNTAX_T) {
            handleError(e, next, "<type>");
        } else {
            Message.error(getToken(1).beginLine, "SYNTAX-clause missing");
            recovery(next);
        }
        type = new TypeIdentifier();
    }
        {if (true) return new SyntaxPart(type);}
    throw new Error("Missing return statement in function");
  }

  final public WriteSyntaxPart WriteSyntaxPart(Recovery next) throws ParseException {
    Token key;
    Type type;
    key = jj_consume_token(WRITE_SYNTAX_T);
    type = Types();
      {if (true) return new WriteSyntaxPart(type);}
    throw new Error("Missing return statement in function");
  }

  final public Type Types() throws ParseException {
    Type type;
    Token type_t;
    Identifier identifier;
    Restriction restriction;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEQUENCE_OF_T:
      /* 'SEQUENCE OF' always comes with an identifier, stored in the restriction. */
              type_t = jj_consume_token(SEQUENCE_OF_T);
      identifier = TypeIdentifier();
          type = new TypeSequenceOf(identifier);
      break;
    case INTEGER_T:
    case UNSIGNED32_T:
    case UINTEGER32_T:
    case INTEGER32_T:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_T:
        type_t = jj_consume_token(INTEGER_T);
        break;
      case INTEGER32_T:
        type_t = jj_consume_token(INTEGER32_T);
        break;
      case UINTEGER32_T:
        type_t = jj_consume_token(UINTEGER32_T);
        break;
      case UNSIGNED32_T:
        type_t = jj_consume_token(UNSIGNED32_T);
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                   type = new TypeSmi(makeNodeToken(type_t));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_BRACE_T:
      case LEFT_PAREN_T:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LEFT_BRACE_T:
          restriction = RestrictionNamedNumberList();
          break;
        case LEFT_PAREN_T:
          restriction = RestrictionRange();
          break;
        default:
          jj_la1[39] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
              type.addRestriction(restriction);
        break;
      default:
        jj_la1[40] = jj_gen;
        ;
      }
      break;
    case GAUGE32_T:
    case GAUGE_T:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GAUGE_T:
        type_t = jj_consume_token(GAUGE_T);
        break;
      case GAUGE32_T:
        type_t = jj_consume_token(GAUGE32_T);
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          type = new TypeSmi(makeNodeToken(type_t));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_PAREN_T:
        restriction = RestrictionRange();
              type.addRestriction(restriction);
        break;
      default:
        jj_la1[42] = jj_gen;
        ;
      }
      break;
    case BITS_T:
    case BIT_STRING_T:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BITS_T:
        type_t = jj_consume_token(BITS_T);
        break;
      case BIT_STRING_T:
        type_t = jj_consume_token(BIT_STRING_T);
        break;
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          type = new TypeSmi(makeNodeToken(type_t));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_BRACE_T:
        restriction = RestrictionNamedNumberList();
              type.addRestriction(restriction);
        break;
      default:
        jj_la1[44] = jj_gen;
        ;
      }
      break;
    case OCTET_STRING_T:
    case OPAQUE_T:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OCTET_STRING_T:
        type_t = jj_consume_token(OCTET_STRING_T);
        break;
      case OPAQUE_T:
        type_t = jj_consume_token(OPAQUE_T);
        break;
      default:
        jj_la1[45] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          type = new TypeSmi(makeNodeToken(type_t));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_PAREN_T:
        restriction = RestrictionSize(new Recovery(new int[0]));
              type.addRestriction(restriction);
        break;
      default:
        jj_la1[46] = jj_gen;
        ;
      }
      break;
    case OBJECT_IDENTIFIER_T:
      type_t = jj_consume_token(OBJECT_IDENTIFIER_T);
          type = new TypeSmi(makeNodeToken(type_t));
      break;
    case COUNTER_T:
      type_t = jj_consume_token(COUNTER_T);
          type = new TypeSmi(makeNodeToken(type_t));
      break;
    case COUNTER32_T:
      type_t = jj_consume_token(COUNTER32_T);
          type = new TypeSmi(makeNodeToken(type_t));
      break;
    case COUNTER64_T:
      type_t = jj_consume_token(COUNTER64_T);
          type = new TypeSmi(makeNodeToken(type_t));
      break;
    case TIMETICKS_T:
      type_t = jj_consume_token(TIMETICKS_T);
          type = new TypeSmi(makeNodeToken(type_t));
      break;
    case NSAP_ADDRESS_T:
      type_t = jj_consume_token(NSAP_ADDRESS_T);
          type = new TypeSmi(makeNodeToken(type_t));
      break;
    case IP_ADDRESS_T:
      type_t = jj_consume_token(IP_ADDRESS_T);
          type = new TypeSmi(makeNodeToken(type_t));
      break;
    case NETWORK_ADDRESS_T:
      type_t = jj_consume_token(NETWORK_ADDRESS_T);
          type = new TypeSmi(makeNodeToken(type_t));
      break;
    case TYPE_IDENTIFIER_T:
      identifier = TypeIdentifier();
          type = new TypeIdentifier(identifier);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_BRACE_T:
      case LEFT_PAREN_T:
        if (jj_2_8(2)) {
          restriction = RestrictionRange();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LEFT_BRACE_T:
            restriction = RestrictionNamedNumberList();
            break;
          default:
            jj_la1[47] = jj_gen;
            if (jj_2_9(2)) {
              restriction = RestrictionSize(new Recovery(new int[0]));
            } else {
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
              type.addRestriction(restriction);
        break;
      default:
        jj_la1[48] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return type;}
    throw new Error("Missing return statement in function");
  }

  final public RestrictionRange RestrictionRange() throws ParseException {
    RangeList var2;
    Recovery next = new Recovery();
    LParenSymbol(next);
    var2 = RangeList();
    RParenSymbol(next);
      {if (true) return new RestrictionRange(var2);}
    throw new Error("Missing return statement in function");
  }

  final public RestrictionSize RestrictionSize(Recovery next) throws ParseException {
    Token var3;
    RangeList range;
    next.push(SIZE_T);
    LParenSymbol(next);
        next.pop(); /* SIZE_T */

    var3 = jj_consume_token(SIZE_T);
        next.push(RIGHT_PAREN_T);
        next.push(DEC_NUMBER_T);
    LParenSymbol(next);
        next.pop(); /* DEC_NUMBER_T */

    range = RangeList();
        next.pop(); /* RIGHT_PAREN_T */

    RParenSymbol(next);
    RParenSymbol(next);
      {if (true) return new RestrictionSize(range);}
    throw new Error("Missing return statement in function");
  }

  final public RestrictionNamedNumberList RestrictionNamedNumberList() throws ParseException {
    NodeList list = new NodeList();
    NamedNumber item;
    Token comma_t;
    Recovery next = new Recovery();
    next.push(VALUE_IDENTIFIER_T);
    LBraceSymbol(next);
        next.pop(); /* VALUE_IDENTIFIER_T */
        next.push(RIGHT_BRACE_T);
        next.push(COMMA_T);
    item = NamedNumber_Rule(next);
        list.addNode(item);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_T:
        ;
        break;
      default:
        jj_la1[50] = jj_gen;
        break label_10;
      }
      comma_t = jj_consume_token(COMMA_T);
      item = NamedNumber_Rule(next);
            list.addNode(item);
    }
        list.nodes.trimToSize();
        next.pop(); /* COMMA_T */
        next.pop(); /* RIGHT_BRACE_T */

    RBraceSymbol(next);
        {if (true) return new RestrictionNamedNumberList(list);}
    throw new Error("Missing return statement in function");
  }

  final public RangeList RangeList() throws ParseException {
    RangeList list;
    Token sort_t;
    RangeItem range;
    range = RangeItem();
      list = new RangeList(range);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR_T:
        ;
        break;
      default:
        jj_la1[51] = jj_gen;
        break label_11;
      }
      sort_t = jj_consume_token(OR_T);
      range = RangeItem();
          list.addNode(range);
    }
      {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final public RangeItem RangeItem() throws ParseException {
    NumericValue number;
    Token sort_t;
    RangeItem range_item;
    number = NumericValue();
      range_item = new RangeItem(number);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UNTIL_T:
      sort_t = jj_consume_token(UNTIL_T);
      number = NumericValue();
          range_item.addEndNumber(number);
      break;
    default:
      jj_la1[52] = jj_gen;
      ;
    }
      {if (true) return range_item;}
    throw new Error("Missing return statement in function");
  }

  final public NamedNumber NamedNumber_Rule(Recovery next) throws ParseException {
    Identifier identifier = null;
    Token number_t;
    NumericValue number = null;
    try {
      identifier = ValueIdentifier();
      jj_consume_token(LEFT_PAREN_T);
      try {
        number_t = jj_consume_token(DEC_NUMBER_T);
              number = new NumericValue(makeNodeToken(number_t));
      } catch (ParseException e) {
            handleError(e, next, "<number>");
      }
      jj_consume_token(RIGHT_PAREN_T);
    } catch (ParseException e) {
        if (e.currentToken.kind == DEC_NUMBER_T) {
            handleError(e, next, "')' for <named number :" + identifier + ">");
        } else if (e.currentToken.kind == LEFT_PAREN_T) {
            handleError(e, next, "<number> for <named number :" + identifier + ">");
        } else if (e.currentToken.kind == VALUE_IDENTIFIER_T) {
            handleError(e, next, "'(' for <named number :" + identifier + ">");
        } else {
            handleError(e, next, "<named number>");
        }
    }
      {if (true) return new NamedNumber(identifier,
                            number);}
    throw new Error("Missing return statement in function");
  }

  final public Identifier ValueIdentifier() throws ParseException {
    ModuleIdentifier module;
    Token dot_t;
    NodeToken value;
    Identifier identifier;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TYPE_IDENTIFIER_T:
      module = ModuleIdentifier();
      dot_t = jj_consume_token(DOT_T);
      value = ValueExpansion();
          identifier = Identifier.Value(module,
                            value);
      break;
    case CURRENT_T:
    case DEPRECATED_T:
    case OBSOLETE_T:
    case MANDATORY_T:
    case NOT_IMPLEMENTED_T:
    case VALUE_IDENTIFIER_T:
      value = ValueExpansion();
          identifier = Identifier.Value(value);
      break;
    default:
      jj_la1[53] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return identifier;}
    throw new Error("Missing return statement in function");
  }

/**
 * ValueExpansion
 * Is used to group the value identifier with some of the
 * t allowed to be value identifiers as well.
 */
  final public NodeToken ValueExpansion() throws ParseException {
    Token value;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VALUE_IDENTIFIER_T:
      value = jj_consume_token(VALUE_IDENTIFIER_T);
      break;
    case NOT_IMPLEMENTED_T:
      value = jj_consume_token(NOT_IMPLEMENTED_T);
      break;
    case CURRENT_T:
      value = jj_consume_token(CURRENT_T);
      break;
    case DEPRECATED_T:
      value = jj_consume_token(DEPRECATED_T);
      break;
    case OBSOLETE_T:
      value = jj_consume_token(OBSOLETE_T);
      break;
    case MANDATORY_T:
      value = jj_consume_token(MANDATORY_T);
      break;
    default:
      jj_la1[54] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return makeNodeToken(value);}
    throw new Error("Missing return statement in function");
  }

  final public ModuleIdentifier ModuleIdentifier() throws ParseException {
    Token module_id;
    module_id = jj_consume_token(TYPE_IDENTIFIER_T);
      {if (true) return new ModuleIdentifier(makeNodeToken(module_id));}
    throw new Error("Missing return statement in function");
  }

  final public Identifier TypeIdentifier() throws ParseException {
    ModuleIdentifier module_id;
    Token dot_t;
    Token type;
    Identifier identifier;
    if (jj_2_10(2)) {
      module_id = ModuleIdentifier();
      dot_t = jj_consume_token(DOT_T);
      type = jj_consume_token(TYPE_IDENTIFIER_T);
          identifier = Identifier.Type(module_id,
                            makeNodeToken(type));
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TYPE_IDENTIFIER_T:
        type = jj_consume_token(TYPE_IDENTIFIER_T);
          identifier = Identifier.Type(makeNodeToken(type));
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return identifier;}
    throw new Error("Missing return statement in function");
  }

  final public IndexPart IndexPart(Recovery next) throws ParseException {
    Token sort;
    Identifier identifier;
    IndexPart index_part = new IndexList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INDEX_T:
    case AUGMENTS_T:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INDEX_T:
        sort = jj_consume_token(INDEX_T);
                next.push(RIGHT_BRACE_T);
                next.push(IMPLIED_T);
                next.push(VALUE_IDENTIFIER_T);
        LBraceSymbol(next);
        try {
          index_part = IndexList();
                    next.pop(); /* VALUE_IDENTIFIER_T */
                    next.pop(); /* IMPLIED_T */

        } catch (ParseException e) {
                makeError(e.currentToken, "error in INDEX-clause");
                recovery(next);
        }
                next.pop(); /* RIGHT_BRACE_T */

        RBraceSymbol(next);
        break;
      case AUGMENTS_T:
        sort = jj_consume_token(AUGMENTS_T);
                next.push(RIGHT_BRACE_T);
                next.push(VALUE_IDENTIFIER_T);
        LBraceSymbol(next);
        try {
          identifier = ValueIdentifier();
                    index_part = new IndexAugments(identifier);
        } catch (ParseException e) {
                makeError(e.currentToken, "error in AUGMENTS-clause");
                recovery(next);
        }
                next.pop(); /* RIGHT_BRACE_T */

        RBraceSymbol(next);
        break;
      default:
        jj_la1[56] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[57] = jj_gen;
      ;
    }
      {if (true) return index_part;}
    throw new Error("Missing return statement in function");
  }

  final public IndexList IndexList() throws ParseException {
    NodeList list = new NodeList();
    Token implied_t;
    Identifier identifier;
    Token comma_t;
    boolean implied;
      implied = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IMPLIED_T:
      implied_t = jj_consume_token(IMPLIED_T);
      break;
    default:
      jj_la1[58] = jj_gen;
      ;
    }
    identifier = ValueIdentifier();
      list.addNode(new Index(identifier, implied));
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_T:
        ;
        break;
      default:
        jj_la1[59] = jj_gen;
        break label_12;
      }
      comma_t = jj_consume_token(COMMA_T);
          implied = false;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPLIED_T:
        implied_t = jj_consume_token(IMPLIED_T);
              implied = true;
        break;
      default:
        jj_la1[60] = jj_gen;
        ;
      }
      identifier = ValueIdentifier();
          list.addNode(new Index(identifier, implied));
    }
      list.nodes.trimToSize();
      {if (true) return new IndexList(list);}
    throw new Error("Missing return statement in function");
  }

  final public AssignedValue AssignedValue() throws ParseException {
    Recovery next = new Recovery();
    next.push(RIGHT_BRACE_T);
    next.push(DEC_NUMBER_T);
    next.push(VALUE_IDENTIFIER_T);
    NodeList list = new NodeList();
    OidValue item;
    LBraceSymbol(next);
    label_13:
    while (true) {
      item = OidValue();
            list.addNode(item);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURRENT_T:
      case DEPRECATED_T:
      case OBSOLETE_T:
      case MANDATORY_T:
      case NOT_IMPLEMENTED_T:
      case BIN_NUMBER_T:
      case HEX_NUMBER_T:
      case DEC_NUMBER_T:
      case VALUE_IDENTIFIER_T:
      case TYPE_IDENTIFIER_T:
        ;
        break;
      default:
        jj_la1[61] = jj_gen;
        break label_13;
      }
    }
        list.nodes.trimToSize();
        next.pop(3); /* VALUE_IDENTIFIER_T, DEC_NUMBER_T, RIGHT_BRACE_T */

    RBraceSymbol(next);
      {if (true) return new AssignedValue(list);}
    throw new Error("Missing return statement in function");
  }

  final public OidValue OidValue() throws ParseException {
    Identifier name;
    NumericValue numval;
    OidValue oidval;
    Recovery next = new Recovery();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CURRENT_T:
    case DEPRECATED_T:
    case OBSOLETE_T:
    case MANDATORY_T:
    case NOT_IMPLEMENTED_T:
    case VALUE_IDENTIFIER_T:
    case TYPE_IDENTIFIER_T:
      name = ValueIdentifier();
            oidval = new OidValue(name);
            if (getToken(1).kind == LEFT_PAREN_T) {
                LParenSymbol(next);
                oidval.setNumber(NumericValue());
                RParenSymbol(next);
            }
      break;
    case BIN_NUMBER_T:
    case HEX_NUMBER_T:
    case DEC_NUMBER_T:
      numval = NumericValue();
          oidval = new OidValue(numval);
      break;
    default:
      jj_la1[62] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return oidval;}
    throw new Error("Missing return statement in function");
  }

  final public NumericValue NumericValue() throws ParseException {
    Token number;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEC_NUMBER_T:
      number = jj_consume_token(DEC_NUMBER_T);
      break;
    case BIN_NUMBER_T:
      number = jj_consume_token(BIN_NUMBER_T);
      break;
    case HEX_NUMBER_T:
      number = jj_consume_token(HEX_NUMBER_T);
      break;
    default:
      jj_la1[63] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return new NumericValue(makeNodeToken(number));}
    throw new Error("Missing return statement in function");
  }

  DescriptionPart DescriptionPart(Recovery next) throws ParseException {
    return new DescriptionPart(Item_and_Text_Rule(next, DESCRIPTION_T));
  }

  ReferencePart ReferencePart(Recovery next) throws ParseException {
    return new ReferencePart(Item_and_Text_Option_Rule(next, REFERENCE_T));
  }

  ContactInfoPart ContactInfoPart(Recovery next) throws ParseException {
    return new ContactInfoPart(Item_and_Text_Rule(next, CONTACT_INFO_T));
  }

  OrganizationPart OrganizationPart(Recovery next) throws ParseException {
    return new OrganizationPart(Item_and_Text_Rule(next, ORGANIZATION_T));
  }

  final public DefValPart DefValPart(Recovery next) throws ParseException {
    NodeOptional value = new NodeOptional();
    Token defval_t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFVAL_T:
      defval_t = jj_consume_token(DEFVAL_T);
            next.push(RIGHT_BRACE_T);
            next.push(DEC_NUMBER_T);
            next.push(VALUE_IDENTIFIER_T);
            next.push(TEXT_T);
      LBraceSymbol(next);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIN_NUMBER_T:
      case HEX_NUMBER_T:
      case DEC_NUMBER_T:
                NumericValue number;
        number = NumericValue();
                value.addNode(number);
        break;
      case CURRENT_T:
      case DEPRECATED_T:
      case OBSOLETE_T:
      case MANDATORY_T:
      case NOT_IMPLEMENTED_T:
      case VALUE_IDENTIFIER_T:
      case TYPE_IDENTIFIER_T:
                Identifier identifier;
        identifier = ValueIdentifier();
                value.addNode(identifier);
        break;
      case TEXT_T:
                Token text_t;
        text_t = jj_consume_token(TEXT_T);
                value.addNode(makeNodeToken(text_t));
        break;
      default:
        jj_la1[64] = jj_gen;
        if (jj_2_11(2)) {
                NodeList list;
          list = BitValueList(next);
                value.addNode(new BitValueList(list));
        } else if (jj_2_12(2)) {
                AssignedValue oidValue;
          oidValue = AssignedValue();
                value.addNode(oidValue);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
            next.pop(4); /* TEXT_T, VALUE_IDENTIFIER_T, DEC_NUMBER_T, RIGHT_BRACE_T */

      RBraceSymbol(next);
      break;
    default:
      jj_la1[65] = jj_gen;
      ;
    }
        {if (true) return new DefValPart(value);}
    throw new Error("Missing return statement in function");
  }

  final public NodeList BitValueList(Recovery next) throws ParseException {
    next.push(VALUE_IDENTIFIER_T);
    NodeList list = new NodeList();
    LBraceSymbol(next);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CURRENT_T:
    case DEPRECATED_T:
    case OBSOLETE_T:
    case MANDATORY_T:
    case NOT_IMPLEMENTED_T:
    case VALUE_IDENTIFIER_T:
    case TYPE_IDENTIFIER_T:
      list = ValueList(next);
      break;
    default:
      jj_la1[66] = jj_gen;
      ;
    }
        next.pop(); /* VALUE_IDENTIFIER_T */

    RBraceSymbol(next);
      {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  DisplayHintPart DisplayHintPart(Recovery next) throws ParseException {
    return new DisplayHintPart(Item_and_Text_Option_Rule(next, DISPLAY_HINT_T));
  }

  final public LastUpdatedPart LastUpdatedPart(Recovery next) throws ParseException {
    Token key;
    Token utc_time;
    next.push(UTC_TIME_T);
    try {
      key = jj_consume_token(LAST_UPDATED_T);
    } catch (ParseException e) {
        handleError(e, next, "LAST-UPDATED");
    } finally {
        next.pop(); /* UTC_TIME_T */

    }
    try {
      utc_time = jj_consume_token(UTC_TIME_T);
    } catch (ParseException e) {
        handleError(e, next, "LAST-UPDATED", "<utc-time>");
        utc_time = Token.newToken(UTC_TIME_T);
        utc_time.image = "";
    }
      {if (true) return new LastUpdatedPart(makeNodeToken(utc_time));}
    throw new Error("Missing return statement in function");
  }

  UnitsPart UnitsPart(Recovery next) throws ParseException {
    return new UnitsPart(Item_and_Text_Option_Rule(next, UNITS_T));
  }

  ProductReleasePart ProductReleasePart(Recovery next) throws ParseException {
    return new ProductReleasePart(Item_and_Text_Rule(next, PRODUCT_RELEASE_T));
  }

  final public NodeList ObjectsPart(boolean isOption, Recovery next) throws ParseException {
    Token objects_t;
    NodeList list;
    try {
      objects_t = jj_consume_token(OBJECTS_T);
    } catch (ParseException e) {
        if (isOption) {
            {if (true) return new NodeList();}
        }
        handleError(e, LEFT_BRACE_T, "'OBJECTS'");
    }
    list = BracedValueList(next);
      {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final public NodeList NotificationPart(Recovery next) throws ParseException {
    Token key;
    NodeList list;
    try {
      key = jj_consume_token(NOTIFICATIONS_T);
    } catch (ParseException e) {
        if (next.contains(e.currentToken.kind)) {
            {if (true) return new NodeList();}
        }
        handleError(e, LEFT_BRACE_T, "'NOTIFICATIONS'");
    }
    list = BracedValueList(next);
      {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

/**
 * EnterprisePart is for a SMIv1 TRAP-TYPE.
 */
  final public EnterprisePart EnterprisePart(Recovery next) throws ParseException {
    Token key;
    Identifier var;
    key = jj_consume_token(ENTERPRISE_T);
    try {
      var = ValueIdentifier();
    } catch (ParseException e) {
        handleError(e, next, "<value identifier>");
        var = Identifier.Keyword(makeNodeToken(VALUE_IDENTIFIER_T));
    }
      {if (true) return new EnterprisePart(var);}
    throw new Error("Missing return statement in function");
  }

/**
 * VariablesPart is for a SMIv1 TRAP-TYPE.
 * Equivalent to a ObjectsPart of the NOTIFICATION-TYPE.
 */
  final public NodeList VariablesPart(Recovery next) throws ParseException {
    Token var;
    NodeList list = new NodeList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VARIABLES_T:
      var = jj_consume_token(VARIABLES_T);
      list = BracedValueList(next);
      break;
    default:
      jj_la1[67] = jj_gen;
      ;
    }
      {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

/**
 * BracedValueList
 * Added for easier and less duplication of error recovery
 * of the ValueList.
 * ValueList has its own recovery inside.
 */
  final public NodeList BracedValueList(Recovery next) throws ParseException {
    next.push(VALUE_IDENTIFIER_T);
    NodeList list;
    LBraceSymbol(next);
    list = ValueList(next);
        next.pop(); /* VALUE_IDENTITIFIER_T */

    RBraceSymbol(next);
      {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final public NodeList ValueList(Recovery next) throws ParseException {
    NodeList list = new NodeList();
    Identifier identifier;
    Token comma_t;
    next.push(COMMA_T);
    next.push(RIGHT_BRACE_T);
    try {
      identifier = ValueIdentifier();
          list.addNode(identifier);
    } catch (ParseException e) {
        handleError(e, next, "<value identifier>");
    }
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_T:
        ;
        break;
      default:
        jj_la1[68] = jj_gen;
        break label_14;
      }
      try {
        comma_t = jj_consume_token(COMMA_T);
        identifier = ValueIdentifier();
              list.addNode(identifier);
      } catch (ParseException e) {
            handleError(e, next, "<value identifier>");
      }
    }
      list.nodes.trimToSize();
      {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

/**
 * BracedValueTypeList
 * Added for easier and less duplication of error recovery
 * of the '{' ValueType (',' ValueType )* '}'.
 * ValueType has its own recovery inside.
 */
  final public NodeList BracedValueTypeList() throws ParseException {
    NodeList list = new NodeList();
    ValueType value_type;
    Token comma_t;
    Recovery next = new Recovery();
    next.push(VALUE_IDENTIFIER_T);
    LBraceSymbol(next);
        next.pop(); /* VALUE_IDENTIFIER_T */
        next.push(COMMA_T);
        next.push(RIGHT_BRACE_T);
    value_type = ValueType(next);
        list.addNode(value_type);
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_T:
        ;
        break;
      default:
        jj_la1[69] = jj_gen;
        break label_15;
      }
      comma_t = jj_consume_token(COMMA_T);
      value_type = ValueType(next);
            list.addNode(value_type);
    }
        next.pop(); /* COMMA_T */

    RBraceSymbol(next);
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

/**
 * ValueType
 * Used for combination of ValueIdentifier and a Type combination
 * inside a CHOICE definition.
 */
  final public ValueType ValueType(Recovery next) throws ParseException {
    Identifier identifier;
    Type type;
    Identifier type_exception;
    try {
      identifier = ValueIdentifier();
    } catch (ParseException e) {
        handleError(e, next, "<value identifier>");
        {if (true) return null;}
    }
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJECT_IDENTIFIER_T:
      case INTEGER_T:
      case BITS_T:
      case BIT_STRING_T:
      case OCTET_STRING_T:
      case SEQUENCE_OF_T:
      case COUNTER32_T:
      case COUNTER_T:
      case GAUGE32_T:
      case GAUGE_T:
      case TIMETICKS_T:
      case OPAQUE_T:
      case IP_ADDRESS_T:
      case NETWORK_ADDRESS_T:
      case NSAP_ADDRESS_T:
      case COUNTER64_T:
      case UNSIGNED32_T:
      case UINTEGER32_T:
      case INTEGER32_T:
      case TYPE_IDENTIFIER_T:
        type = Types();
        break;
      case INDEX_SYNTAX_T:
      case APPLICATION_SYNTAX_T:
      case OBJECT_SYNTAX_T:
      case SIMPLE_SYNTAX_T:
        type_exception = TypeIdentifierException();
              type = new TypeIdentifier(type_exception);
        break;
      default:
        jj_la1[70] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        handleError(e, next, "<type>");
        {if (true) return null;}
    }
      {if (true) return new ValueType(identifier, type);}
    throw new Error("Missing return statement in function");
  }

  final public Identifier TypeIdentifierException() throws ParseException {
    Token syntax_t;
    Identifier identifier;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INDEX_SYNTAX_T:
      syntax_t = jj_consume_token(INDEX_SYNTAX_T);
          identifier = Identifier.Keyword(makeNodeToken(syntax_t));
      break;
    case APPLICATION_SYNTAX_T:
      syntax_t = jj_consume_token(APPLICATION_SYNTAX_T);
          identifier = Identifier.Keyword(makeNodeToken(syntax_t));
      break;
    case OBJECT_SYNTAX_T:
      syntax_t = jj_consume_token(OBJECT_SYNTAX_T);
          identifier = Identifier.Keyword(makeNodeToken(syntax_t));
      break;
    case SIMPLE_SYNTAX_T:
      syntax_t = jj_consume_token(SIMPLE_SYNTAX_T);
          identifier = Identifier.Keyword(makeNodeToken(syntax_t));
      break;
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return identifier;}
    throw new Error("Missing return statement in function");
  }

  final public void AssignSymbol(Recovery next) throws ParseException {
    Token assign_t;
    try {
      assign_t = jj_consume_token(ASSIGN_T);
    } catch (ParseException e) {
        handleError(e, next, "'::='");
    }
  }

  final public void LBraceSymbol(Recovery next) throws ParseException {
    try {
      jj_consume_token(LEFT_BRACE_T);
    } catch (ParseException e) {
        handleError(e, next, "'{'");
    }
  }

  final public void RBraceSymbol(Recovery next) throws ParseException {
    try {
      jj_consume_token(RIGHT_BRACE_T);
    } catch (ParseException e) {
        handleError(e, next, "'}'");
    }
  }

  final public void LParenSymbol(Recovery next) throws ParseException {
    try {
      jj_consume_token(LEFT_PAREN_T);
    } catch (ParseException e) {
        handleError(e, next, "'('");
    }
  }

  final public void RParenSymbol(Recovery next) throws ParseException {
    try {
      jj_consume_token(RIGHT_PAREN_T);
    } catch (ParseException e) {
        handleError(e, next, "')'");
    }
  }

  NodeToken Item_and_Text_Rule(Recovery next, int item) throws ParseException {
    Token key;
    NodeToken text;

    if (getToken(1).kind == item) {
        /* The item-token is found. */
        key = getNextToken();
        if (getToken(1).kind == TEXT_T) {
            /* The item-token is followed by TEXT-token. */
            text = makeNodeToken(getNextToken());
        } else {
            /* The item-token is not followed by TEXT-token. */
            Message.error(key.beginLine, key + " missing <quoted string>");
            text = makeNodeToken(TEXT_T, "<quoted string>");
        }
    } else if (getToken(1).kind == TEXT_T) {
        /* The item-token is missing, but the TEXT-token is there. */
        String str = tokenImage[item].replace('"', '\'');
        Message.error(getToken(1).beginLine, str + " keyword missing");
        text=makeNodeToken(getNextToken());
    } else {
        /* The Item-Text clause is missing at all. */
        StringBuffer str = new StringBuffer(tokenImage[item]);
        str.deleteCharAt(0);
        str.deleteCharAt(str.length()-1);
        Message.error(getToken(1).beginLine, str + "-clause missing");
        recovery(next);
        text = makeNodeToken(TEXT_T, "<quoted string>");
    }
    return text;
  }

  NodeOptional Item_and_Text_Option_Rule(Recovery next, int item) throws ParseException {
NodeOptional text = new NodeOptional();

    if (getToken(1).kind == item) {
        /* The Item-Text Rule is available. */
        text.addNode(Item_and_Text_Rule(next, item));
    }
    return text;
  }

  void ErrorRule(Recovery next, String msg) throws ParseException {
    makeError(getToken(0), msg);
    recovery(next);
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  final private boolean jj_3R_56() {
    if (jj_scan_token(APPLICATION_SYNTAX_T)) return true;
    return false;
  }

  final private boolean jj_3R_40() {
    if (jj_scan_token(MODULE_COMPLIANCE_T)) return true;
    return false;
  }

  final private boolean jj_3R_19() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_33()) {
    jj_scanpos = xsp;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3R_41()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_scan_token(INDEX_SYNTAX_T)) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    if (jj_scan_token(OBJECT_IDENTITY_T)) return true;
    return false;
  }

  final private boolean jj_3R_20() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(93)) {
    jj_scanpos = xsp;
    if (jj_scan_token(94)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) {
    jj_scanpos = xsp;
    if (jj_scan_token(89)) {
    jj_scanpos = xsp;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(98)) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_3R_61()) return true;
    return false;
  }

  final private boolean jj_3R_60() {
    if (jj_3R_17()) return true;
    return false;
  }

  final private boolean jj_3R_47() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_scan_token(OBJECT_IDENTIFIER_T)) return true;
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_scan_token(TYPE_IDENTIFIER_T)) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_20()) return true;
    if (jj_3R_18()) return true;
    if (jj_3R_21()) return true;
    if (jj_3R_22()) return true;
    return false;
  }

  final private boolean jj_3R_29() {
    if (jj_3R_50()) return true;
    Token xsp;
    if (jj_3R_53()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_53()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_26() {
    if (jj_3R_48()) return true;
    if (jj_scan_token(SIZE_T)) return true;
    return false;
  }

  final private boolean jj_3R_45() {
    if (jj_scan_token(OCTET_STRING_T)) return true;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_3R_27()) return true;
    if (jj_scan_token(DOT_T)) return true;
    if (jj_scan_token(TYPE_IDENTIFIER_T)) return true;
    return false;
  }

  final private boolean jj_3R_44() {
    if (jj_scan_token(BIT_STRING_T)) return true;
    return false;
  }

  final private boolean jj_3R_16() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3R_30()) return true;
    }
    return false;
  }

  final private boolean jj_3R_25() {
    if (jj_3R_48()) return true;
    if (jj_3R_49()) return true;
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_scan_token(NOTIFICATION_GROUP_T)) return true;
    return false;
  }

  final private boolean jj_3R_43() {
    if (jj_scan_token(INTEGER_T)) return true;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_3R_26()) return true;
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_3R_62()) return true;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_3R_25()) return true;
    return false;
  }

  final private boolean jj_3R_22() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_27() {
    if (jj_scan_token(TYPE_IDENTIFIER_T)) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_17()) return true;
    if (jj_3R_19()) return true;
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_scan_token(MODULE_IDENTITY_T)) return true;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_3R_17()) return true;
    if (jj_scan_token(TRAP_TYPE_T)) return true;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_3R_59()) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_17()) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_16()) return true;
    if (jj_3R_18()) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_16()) return true;
    return false;
  }

  final private boolean jj_3R_51() {
    if (jj_3R_60()) return true;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_scan_token(LEFT_PAREN_T)) return true;
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_scan_token(NOTIFICATION_TYPE_T)) return true;
    return false;
  }

  final private boolean jj_3R_54() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(117)) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) {
    jj_scanpos = xsp;
    if (jj_scan_token(68)) {
    jj_scanpos = xsp;
    if (jj_scan_token(69)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_28() {
    if (jj_3R_50()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_51()) jj_scanpos = xsp;
    if (jj_3R_52()) return true;
    return false;
  }

  final private boolean jj_3R_52() {
    if (jj_scan_token(RIGHT_BRACE_T)) return true;
    return false;
  }

  final private boolean jj_3R_62() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(114)) {
    jj_scanpos = xsp;
    if (jj_scan_token(112)) {
    jj_scanpos = xsp;
    if (jj_scan_token(113)) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_32() {
    if (jj_3R_54()) return true;
    return false;
  }

  final private boolean jj_3R_41() {
    if (jj_scan_token(AGENT_CAPABILITIES_T)) return true;
    return false;
  }

  final private boolean jj_3R_64() {
    if (jj_3R_62()) return true;
    return false;
  }

  final private boolean jj_3R_24() {
    if (jj_3R_47()) return true;
    return false;
  }

  final private boolean jj_3R_31() {
    if (jj_3R_27()) return true;
    if (jj_scan_token(DOT_T)) return true;
    if (jj_3R_54()) return true;
    return false;
  }

  final private boolean jj_3R_50() {
    if (jj_scan_token(LEFT_BRACE_T)) return true;
    return false;
  }

  final private boolean jj_3R_23() {
    if (jj_3R_20()) return true;
    return false;
  }

  final private boolean jj_3_12() {
    if (jj_3R_29()) return true;
    return false;
  }

  final private boolean jj_3R_42() {
    if (jj_scan_token(LEFT_SQUARE_T)) return true;
    return false;
  }

  final private boolean jj_3R_17() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_31()) {
    jj_scanpos = xsp;
    if (jj_3R_32()) return true;
    }
    return false;
  }

  final private boolean jj_3_6() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_23()) {
    jj_scanpos = xsp;
    if (jj_3R_24()) return true;
    }
    if (jj_3R_18()) return true;
    if (jj_scan_token(CHOICE_T)) return true;
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_scan_token(OBJECT_GROUP_T)) return true;
    return false;
  }

  final private boolean jj_3R_63() {
    if (jj_3R_17()) return true;
    return false;
  }

  final private boolean jj_3R_21() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_42()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_3R_28()) return true;
    return false;
  }

  final private boolean jj_3R_18() {
    if (jj_scan_token(ASSIGN_T)) return true;
    return false;
  }

  final private boolean jj_3R_61() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) return true;
    }
    return false;
  }

  final private boolean jj_3R_34() {
    if (jj_scan_token(OBJECT_TYPE_T)) return true;
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_scan_token(SIMPLE_SYNTAX_T)) return true;
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_scan_token(OBJECT_SYNTAX_T)) return true;
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_scan_token(OBJECT_IDENTIFIER_T)) return true;
    return false;
  }

  public SmiGrammarTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[72];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x1000,0xf8000000,0x2000,0xf8000000,0x10000,0xf8000000,0xf8000000,0x0,0x0,0xf8000000,0x44000000,0xbc000000,0x0,0x0,0x0,0x200000,0x80000,0x80000,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa0000,0xa0000,0x0,0x80000,0x0,0x20000,0x0,0x80000,0x20000,0xa0000,0x4000000,0x10000,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x10000,0x4000000,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x1f,0x0,0x1f,0x0,0x1f,0x1f,0x0,0x0,0x1f,0x0,0xf,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x800,0x0,0x1000,0x8002000,0x100000,0x200000,0x0,0x8002000,0x4000,0x10000,0x100000,0x200000,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2800000,0x2800000,0x1000000,0x0,0x1000000,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0xffc0803c,0x0,0xffc0803c,0x0,0xffc00000,0x0,0xffc00000,0xffc00000,0x0,0xffff0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd0000,0x0,0x3c,0x1c0,0xfe00,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0x0,0x0,0x0,0x0,0x0,0x1c0,0x0,0x10000,0x0,0x0,0x3000000,0x0,0x60000,0x0,0x8080000,0x0,0x0,0x0,0xffdf0000,0x0,0x0,0x0,0x803c,0x803c,0x0,0x0,0x0,0x0,0x0,0x0,0x803c,0x803c,0x0,0x803c,0x0,0x803c,0x1,0x0,0x0,0xffdf0000,0x0,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x400000,0x0,0x60007f,0x0,0x60007f,0x0,0x7f,0x0,0x7,0x7f,0x0,0x400007,0x0,0x3800,0xc000,0xc000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400007,0x0,0x0,0x100,0x600000,0x200000,0x400000,0x0,0x0,0x0,0x0,0x0,0x670000,0x670000,0x70000,0x770000,0x0,0x600000,0x0,0x0,0x0,0x40007f,0x78,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[12];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public SmiGrammar(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SmiGrammarTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 72; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 72; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public SmiGrammar(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SmiGrammarTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 72; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 72; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public SmiGrammar(SmiGrammarTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 72; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(SmiGrammarTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 72; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[119];
    for (int i = 0; i < 119; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 72; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 119; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 12; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
